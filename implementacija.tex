Za implementaciju opisanog algoritma koristili smo programski jezik C++ te razvojno okruženje Visual Studio Code.

\section{Vađenje podataka}
Kod vađenja podataka koristili smo vektore za spremanje informacija o pozicijama i duljinama nizova malih znakova, N-ova i drugih znakova jer su nam potrebne veličine i količine podataka na početku nepoznate. Prvo smo izvadili informacije o malim znakovima krećući se znak po znak, bilježeći mjesto i duljinu niza. Mjesta, tj. pozicije koje će se spominjati su relativne na poziciju koja je došla prije njih, a ne apsolutne da označavaju na kojoj su udaljenosti od početka sekvence. Podaci o malim znakovima su uz čisti niz ACGT jedino što je potrebno dobiti obradom referentne sekvence tako da smo putem micali sve ostale znakove. Tijekom pomicanja po sekvencama male znakove pretvaramo u velike. Sva ostala obrada i vađenje podataka se odnosi samo na sekvence koje želimo sažeti. Potrebna su sad još dva prolaska po sekvenci velikih znakova kako bi dohvatili informacije o N znakovima i ostalim znakovima. Za N znakove smo uzeli pozicije početka niza N znakova te duljinu niza krećući se znak po znak. Za ostale znakove smo uzeli poziciju i o kojem znaku se radi ponovo krećući se znak po znak. Sad mičemo N i ostale znakove iz niza i imamo čisti niz sastavljen od A, C, G i T koji predajemo na podudaranja.
\pagebreak
\section{Podudaranje podataka}
Za implementaciju podudaranja bilo je potrebno odabrati način na koji izračunati hash vrijednost ACGT niza za podudaranje prve razine te kombinacije pozicije, duljine i nepodudarajućih znakova za podudaranje druge razine. Metoda izračuna hash vrijednosti koju smo odabrali je polinomska rekurzivna hash funkcija. Koristili smo gotovi algoritam kao osnovu za implementaciju te funkcije \cite{hashing} te smo joj dodali funkciju za kodiranje znakova A,C,G i T u brojeve 1,2,3 i 4.
Za ostvarenje hash tablice koristili smo strukturu \textit{unordered map} zbog konstantog vremena pretraživanja, dok smo za zapis vrijednosti pozicija i duljina segmenata, kao i nepodudarajućih znakova koristili vektore zbog mogućnosti mijenjanja veličine te manje prostorne složenosti od strukture \textit{list}.

\section{Kodiranje podataka}
Id segmenta prepisuje se u novu datoteku. Zapisujemo i duljinu cijele sekvence prije vađenja podataka. Duljine linija zapisuju se pomoću \textit{run-length-encoding}-a \cite{hrcm}. To znači da podatke zapisujemo u paru (\textit{vrijednost  broj}) gdje se \textit{vrijednost} pojavljuje \textit{broj} puta za redom. Zapis informacija o N i ostalim znakovima je sličan jer kombiniramo pozicije i duljine/znakove u jednu liniju za svaku od tih informacija. Kombinacija za N znakove je \textit{pozicija duljina} po redu kako se pojavljuju u originalnoj sekvenci. Kombinacija za ostale znakove je \textit{pozicija (vrijednost znaka umanjena za vrijednost "A")} po redu kako se pojavljuju u originalnoj sekvenci. Podudaranja malih znakova također prolazi kroz \textit{run-length-encoding} \cite{hrcm} prije zapisa u datoteku, a nakon toga zapisujemo razlike u malim slovima u formatu \textit{pozicija duljina}. Ostala podudaranja zapisuju se u formatu u kojem se nalaze nakon obrade, smatra se da su već u kodiranom obliku.

\section{Dekompresija}
Dekompresija koristi sve korake ranije navedene te većinu istih struktura i algoritama, ali u obrnutom smjeru kako bi od formata što smo dobili kompresijom dobili originalne sekvence. Svaka dekomprimirana sekvenca zapisuje se u svoju datoteku.